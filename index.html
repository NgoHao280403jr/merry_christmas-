<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giáng Sinh</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; }
        #video-container { transform: scaleX(-1); }
        .glass-ui { background: rgba(20, 0, 10, 0.6); backdrop-filter: blur(12px); border: 1px solid rgba(226, 223, 24, 0.2); }
        .glow { text-shadow: 0 0 10px rgba(224, 193, 14, 0.966); }
    </style>
</head>
<body class="text-white font-sans">

    <div class="absolute top-4 left-4 z-50 w-72">
        <div id="info-card" class="glass-ui p-5 rounded-xl shadow-2xl transition-all duration-300">
            <h1 class="text-xl font-bold mb-3 text-yellow-400 tracking-widest text-center border-b border-yellow-500/30 pb-2">MERRY CHRISTMAS</h1>
            
            <div class="space-y-4 text-sm">
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 flex items-center justify-center bg-yellow-500/20 rounded-full text-lg border border-yellow-500/50">✊</div>
                    <div>
                        <span class="block font-bold text-yellow-100">Nắm tay</span>
                        <span class="text-xs text-yellow-300/70">Hiện Cây & Chữ Vàng</span>
                    </div>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 flex items-center justify-center bg-white/10 rounded-full text-lg border border-white/20">✋</div>
                    <div>
                        <span class="block font-bold text-gray-100">Mở bàn tay</span>
                        <span class="text-xs text-gray-400">Phân tán hạt</span>
                    </div>
                </div>
            </div>
            
            <button onclick="toggleInfo()" class="mt-4 w-full py-1 text-[10px] text-yellow-500/50 hover:text-yellow-400 uppercase tracking-widest">ẨN HƯỚNG DẪN</button>
        </div>
        <button id="show-btn" onclick="toggleInfo()" class="hidden glass-ui px-4 py-2 rounded-xl font-bold text-yellow-400 text-xs tracking-widest">HIỆN HƯỚNG DẪN</button>
    </div>

    <div class="absolute bottom-6 left-6 z-50 flex flex-col items-center gap-2">
        <div id="cam-border" class="p-1 rounded-full border-2 border-red-900 bg-black/80 transition-colors duration-500 shadow-[0_0_15px_rgba(0,0,0,0.5)]">
            <div id="video-container" class="w-24 h-24 rounded-full overflow-hidden relative">
                <video id="input-video" class="w-full h-full object-cover opacity-60"></video>
            </div>
        </div>
        <span id="status-text" class="text-[10px] font-mono font-bold tracking-[0.2em] text-red-500 uppercase glow">Đang Khởi Tạo</span>
    </div>

    <div id="scene-container" class="w-full h-screen"></div>

    <script>
        /* -------------------------------------------------------------------------- */
        /* CẤU HÌNH (CONFIGURATION)                                                   */
        /* -------------------------------------------------------------------------- */
        const CONFIG = {
            particleCount: 20000, 
            treeHeight: 45,
            baseRadius: 16,
            scatterRadius: 80,
            camDefaultZ: 75,
            colors: {
                // MÀU CÂY (Xanh lá)
                treeTop: new THREE.Color('#34d399'),   // Emerald Green
                treeBot: new THREE.Color('#064e3b'),   // Deep Green
                
                // MÀU TRANG TRÍ (Giữ nguyên để cây đẹp)
                ornamentRed: new THREE.Color('#ef4444'),
                ornamentGold: new THREE.Color('#fbbf24'),
                ornamentBlue: new THREE.Color('#3b82f6'),
                
                // MÀU CHỮ (Chỉ dùng Vàng Kim)
                textGold: new THREE.Color('#ffffff'),     // GOLD CHUẨN
                star: new THREE.Color('#ffddaa')          // Sao đỉnh
            }
        };

        const STATE = {
            mode: 'SCATTER', 
            zoom: CONFIG.camDefaultZ,
            time: 0
        };

        /* -------------------------------------------------------------------------- */
        /* SETUP THREE.JS                                                             */
        /* -------------------------------------------------------------------------- */
        const container = document.getElementById('scene-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.02); // Sương mù tối màu

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.camDefaultZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        /* -------------------------------------------------------------------------- */
        /* TẠO TỌA ĐỘ CHỮ                                                             */
        /* -------------------------------------------------------------------------- */
        function generateTextCoordinates() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 500; 
            const height = 250;
            canvas.width = width;
            canvas.height = height;

            ctx.fillStyle = 'white';
            ctx.font = '900 60px "Arial", sans-serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            ctx.fillText('MERRY', width / 2, height / 2 - 35);
            ctx.fillText('CHRISTMAS', width / 2, height / 2 + 35);

            const imgData = ctx.getImageData(0, 0, width, height);
            const pixels = imgData.data;
            const coords = [];

            for (let y = 0; y < height; y += 3) {
                for (let x = 0; x < width; x += 3) {
                    const alpha = pixels[(y * width + x) * 4 + 3];
                    if (alpha > 128) {
                        coords.push({
                            x: (x - width / 2) * 0.2,
                            y: -(y - height / 2) * 0.2
                        });
                    }
                }
            }
            return coords;
        }

        const textCoords = generateTextCoordinates();

        /* -------------------------------------------------------------------------- */
        /* HỆ THỐNG HẠT                                                               */
        /* -------------------------------------------------------------------------- */
        const geometry = new THREE.BufferGeometry();
        const posCurrent = new Float32Array(CONFIG.particleCount * 3);
        const posCombined = new Float32Array(CONFIG.particleCount * 3); 
        const posScatter = new Float32Array(CONFIG.particleCount * 3);
        const colorsCombined = new Float32Array(CONFIG.particleCount * 3); 
        const sizes = new Float32Array(CONFIG.particleCount);

        const colorHelper = new THREE.Color();

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const i3 = i * 3;
            const isTextParticle = i < textCoords.length;

            if (isTextParticle) {
                // === [LOGIC CHỮ: VÀNG KIM] ===
                const textPt = textCoords[i];
                posCombined[i3] = textPt.x;
                posCombined[i3+1] = textPt.y - 25; 
                posCombined[i3+2] = (Math.random() - 0.5) * 2; 

                // CHỈ SET MÀU VÀNG KIM
                colorHelper.set(CONFIG.colors.textGold);
                
                // Tạo một chút biến thể độ sáng để trông lấp lánh như kim loại
                const brightness = 0.8 + Math.random() * 0.4; 
                colorsCombined[i3] = colorHelper.r * brightness;
                colorsCombined[i3+1] = colorHelper.g * brightness;
                colorsCombined[i3+2] = colorHelper.b * brightness;
                
                sizes[i] = 1.3; // Hạt chữ to hơn chút

            } else {
                // === [LOGIC CÂY: XANH LÁ] ===
                let txTree, tyTree, tzTree, rTree, angleTree, hTree;
                const type = Math.random(); 

                if (type > 0.96) { // Quả châu
                    hTree = Math.random();
                    rTree = (1 - hTree) * CONFIG.baseRadius * 0.9 + 1; 
                    angleTree = Math.random() * Math.PI * 2;
                    
                    const colorRand = Math.random();
                    if(colorRand > 0.66) colorHelper.set(CONFIG.colors.ornamentRed);
                    else if(colorRand > 0.33) colorHelper.set(CONFIG.colors.ornamentGold);
                    else colorHelper.set(CONFIG.colors.ornamentBlue);

                    sizes[i] = 2.0;
                } else if (type > 0.85) { // Dây kim tuyến
                    hTree = Math.random();
                    angleTree = (hTree * 10 * Math.PI * 2);
                    rTree = (1-hTree) * CONFIG.baseRadius + 0.5;
                    colorHelper.set(CONFIG.colors.ornamentGold);
                    sizes[i] = 0.8;
                } else { 
                    // === LÁ THÔNG: XANH ===
                    hTree = Math.random();
                    angleTree = i * 0.15;
                    rTree = (1 - hTree) * CONFIG.baseRadius + (Math.random() - 0.5) * 1.5;
                    
                    // Gradient từ Xanh đậm (gốc) lên Xanh ngọc (ngọn)
                    colorHelper.lerpColors(CONFIG.colors.treeBot, CONFIG.colors.treeTop, hTree);
                    sizes[i] = 0.6;
                }

                // Lưu màu cây
                if(type <= 0.96 && type > 0.85) { // Dây kim tuyến
                     colorsCombined[i3] = colorHelper.r;
                     colorsCombined[i3+1] = colorHelper.g;
                     colorsCombined[i3+2] = colorHelper.b;
                } else if(type <= 0.85) { // Lá thông
                     colorsCombined[i3] = colorHelper.r;
                     colorsCombined[i3+1] = colorHelper.g;
                     colorsCombined[i3+2] = colorHelper.b;
                } else { // Ornament
                     colorsCombined[i3] = colorHelper.r;
                     colorsCombined[i3+1] = colorHelper.g;
                     colorsCombined[i3+2] = colorHelper.b;
                }

                txTree = Math.cos(angleTree) * rTree;
                tyTree = (hTree * CONFIG.treeHeight) - (CONFIG.treeHeight / 2) + 15; 
                tzTree = Math.sin(angleTree) * rTree;

                posCombined[i3] = txTree;
                posCombined[i3+1] = tyTree;
                posCombined[i3+2] = tzTree;
            }

            // --- Scatter Logic ---
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = CONFIG.scatterRadius * Math.cbrt(Math.random());
            
            posScatter[i3] = r * Math.sin(phi) * Math.cos(theta);
            posScatter[i3+1] = r * Math.sin(phi) * Math.sin(theta);
            posScatter[i3+2] = r * Math.cos(phi);

            posCurrent[i3] = posScatter[i3];
            posCurrent[i3+1] = posScatter[i3+1];
            posCurrent[i3+2] = posScatter[i3+2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(posCurrent, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colorsCombined.slice(), 3)); 
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Texture
        const canvasMap = document.createElement('canvas');
        canvasMap.width = 32; canvasMap.height = 32;
        const ctxMap = canvasMap.getContext('2d');
        const grad = ctxMap.createRadialGradient(16,16,0,16,16,16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(0.4, 'rgba(255,255,255,0.3)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctxMap.fillStyle = grad;
        ctxMap.fillRect(0,0,32,32);
        const texture = new THREE.CanvasTexture(canvasMap);

        const material = new THREE.PointsMaterial({
            size: 1,
            vertexColors: true,
            map: texture,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.95 
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Star
        const starGeo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([0, CONFIG.treeHeight/2 + 17, 0], 3));
        const starMat = new THREE.PointsMaterial({ size: 10, color: CONFIG.colors.star, map: texture, blending: THREE.AdditiveBlending, transparent:true });
        const starMesh = new THREE.Points(starGeo, starMat);
        starMesh.visible = false;
        scene.add(starMesh);

        /* -------------------------------------------------------------------------- */
        /* ANIMATION LOOP                                                             */
        /* -------------------------------------------------------------------------- */
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            STATE.time += dt;

            camera.position.z += (STATE.zoom - camera.position.z) * 0.05;

            const positions = particles.geometry.attributes.position.array;
            const cols = particles.geometry.attributes.color.array;
            
            let targetArray;
            let speed;
            
            if (STATE.mode === 'COMBINED') {
                targetArray = posCombined;
                speed = 0.06;
                starMesh.visible = true;
            } else { 
                targetArray = posScatter;
                speed = 0.03;
                starMesh.visible = false;
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                let tx = targetArray[i3];
                let ty = targetArray[i3+1];
                let tz = targetArray[i3+2];

                if (STATE.mode === 'COMBINED') {
                    if (ty > -10) { // Cây
                        const breathe = 1.0 + Math.sin(STATE.time * 2 + ty * 0.1) * 0.003;
                        tx *= breathe;
                        tz *= breathe;
                    }
                } else { // Scatter
                    tx += Math.sin(STATE.time + i) * 0.5;
                }

                positions[i3] += (tx - positions[i3]) * speed;
                positions[i3+1] += (ty - positions[i3+1]) * speed;
                positions[i3+2] += (tz - positions[i3+2]) * speed;

                // Color Logic
                if (STATE.mode === 'COMBINED') {
                    // Chuyển dần về màu gốc (Vàng kim cho chữ / Xanh cho cây)
                    cols[i3] += (colorsCombined[i3] - cols[i3]) * 0.05;
                    cols[i3+1] += (colorsCombined[i3+1] - cols[i3+1]) * 0.05;
                    cols[i3+2] += (colorsCombined[i3+2] - cols[i3+2]) * 0.05;
                    
                    // Hiệu ứng lấp lánh (Sparkle)
                    // Nếu là cây: lấp lánh trắng nhẹ
                    // Nếu là chữ: lấp lánh sáng hơn
                    if (Math.random() > 0.995) {
                        cols[i3] = 1; cols[i3+1] = 1; cols[i3+2] = 1;
                    }
                } else {
                    // Khi scatter thì làm sáng lên
                    cols[i3] = Math.min(colorsCombined[i3] * 1.5, 1);
                    cols[i3+1] = Math.min(colorsCombined[i3+1] * 1.5, 1);
                    cols[i3+2] = Math.min(colorsCombined[i3+2] * 1.5, 1);
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;

            if (STATE.mode === 'COMBINED') {
                particles.rotation.y = Math.sin(STATE.time * 0.2) * 0.15;
            } else {
                particles.rotation.y += 0.02 * dt;
            }

            if (starMesh.visible) {
                starMat.opacity = 0.7 + Math.sin(STATE.time * 5) * 0.3;
                starMesh.rotation.y = particles.rotation.y; 
            }

            renderer.render(scene, camera);
        }
        animate();

        /* -------------------------------------------------------------------------- */
        /* MEDIA PIPE & GESTURE                                                       */
        /* -------------------------------------------------------------------------- */
        const videoElement = document.getElementById('input-video');
        const statusBorder = document.getElementById('cam-border');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                statusBorder.classList.replace('border-red-900', 'border-yellow-400');
                statusText.innerText = "ĐANG THEO DÕI";
                statusText.classList.replace('text-red-500', 'text-yellow-400');
                detectGesture(lm);
            } else {
                statusBorder.classList.replace('border-yellow-400', 'border-red-900');
                statusText.innerText = "ĐANG TÌM KIẾM";
                statusText.classList.replace('text-yellow-400', 'text-red-500');
            }
        }

        function detectGesture(lm) {
            const isFingerCurled = (tip, pip, mcp) => { return tip.y > pip.y && pip.y > mcp.y; };
            const thumbTip = lm[4]; const indexTip = lm[8]; const middleTip = lm[12]; const ringTip = lm[16]; const pinkyTip = lm[20];
            const indexPIP = lm[6]; const middlePIP = lm[10]; const ringPIP = lm[14]; const pinkyPIP = lm[18];
            const indexMCP = lm[5]; const middleMCP = lm[9]; const ringMCP = lm[13]; const pinkyMCP = lm[17];
            const wrist = lm[0];

            const isFist = isFingerCurled(indexTip, indexPIP, indexMCP) && isFingerCurled(middleTip, middlePIP, middleMCP) && isFingerCurled(ringTip, ringPIP, ringMCP) && isFingerCurled(pinkyTip, pinkyPIP, pinkyMCP);
            const isOpenHand = !isFingerCurled(indexTip, indexPIP, indexMCP) && !isFingerCurled(middleTip, middlePIP, middleMCP) && !isFingerCurled(ringTip, ringPIP, ringMCP) && !isFingerCurled(pinkyTip, pinkyPIP, pinkyMCP) && (thumbTip.y < wrist.y - 0.05);

            if (isFist) {
                STATE.mode = 'COMBINED';
                STATE.zoom = CONFIG.camDefaultZ;
                statusText.innerText = "NẮM TAY: HIỆN HÌNH";
                statusBorder.classList.replace('border-yellow-400', 'border-yellow-600');
            } else if (isOpenHand) {
                STATE.mode = 'SCATTER';
                statusText.innerText = "MỞ TAY: PHÂN TÁN";
                statusBorder.classList.replace('border-yellow-400', 'border-gray-500');
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraUtils.start();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function toggleInfo() {
            document.getElementById('info-card').classList.toggle('hidden');
            document.getElementById('show-btn').classList.toggle('hidden');
        }
    </script>
</body>
</html>